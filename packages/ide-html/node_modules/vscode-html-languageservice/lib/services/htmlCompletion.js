(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "vscode-languageserver-types", "../parser/htmlScanner", "../parser/htmlTags", "./tagProviders", "../parser/htmlEntities", "vscode-nls", "../utils/strings"], factory);
    }
})(function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var vscode_languageserver_types_1 = require("vscode-languageserver-types");
    var htmlScanner_1 = require("../parser/htmlScanner");
    var htmlTags_1 = require("../parser/htmlTags");
    var tagProviders_1 = require("./tagProviders");
    var htmlEntities_1 = require("../parser/htmlEntities");
    var nls = require("vscode-nls");
    var strings_1 = require("../utils/strings");
    var localize = nls.loadMessageBundle();
    function doComplete(document, position, htmlDocument, settings) {
        var result = {
            isIncomplete: false,
            items: []
        };
        var tagProviders = tagProviders_1.allTagProviders.filter(function (p) { return p.isApplicable(document.languageId) && (!settings || settings[p.getId()] !== false); });
        var text = document.getText();
        var offset = document.offsetAt(position);
        var node = htmlDocument.findNodeBefore(offset);
        if (!node) {
            return result;
        }
        var scanner = htmlScanner_1.createScanner(text, node.start);
        var currentTag = '';
        var currentAttributeName;
        function getReplaceRange(replaceStart, replaceEnd) {
            if (replaceEnd === void 0) { replaceEnd = offset; }
            if (replaceStart > offset) {
                replaceStart = offset;
            }
            return { start: document.positionAt(replaceStart), end: document.positionAt(replaceEnd) };
        }
        function collectOpenTagSuggestions(afterOpenBracket, tagNameEnd) {
            var range = getReplaceRange(afterOpenBracket, tagNameEnd);
            tagProviders.forEach(function (provider) {
                provider.collectTags(function (tag, label) {
                    result.items.push({
                        label: tag,
                        kind: vscode_languageserver_types_1.CompletionItemKind.Property,
                        documentation: label,
                        textEdit: vscode_languageserver_types_1.TextEdit.replace(range, tag),
                        insertTextFormat: vscode_languageserver_types_1.InsertTextFormat.PlainText
                    });
                });
            });
            return result;
        }
        function getLineIndent(offset) {
            var start = offset;
            while (start > 0) {
                var ch = text.charAt(start - 1);
                if ("\n\r".indexOf(ch) >= 0) {
                    return text.substring(start, offset);
                }
                if (!isWhiteSpace(ch)) {
                    return null;
                }
                start--;
            }
            return text.substring(0, offset);
        }
        function collectCloseTagSuggestions(afterOpenBracket, inOpenTag, tagNameEnd) {
            if (tagNameEnd === void 0) { tagNameEnd = offset; }
            var range = getReplaceRange(afterOpenBracket, tagNameEnd);
            var closeTag = isFollowedBy(text, tagNameEnd, htmlScanner_1.ScannerState.WithinEndTag, htmlScanner_1.TokenType.EndTagClose) ? '' : '>';
            var curr = node;
            if (inOpenTag) {
                curr = curr.parent; // don't suggest the own tag, it's not yet open
            }
            while (curr) {
                var tag = curr.tag;
                if (tag && (!curr.closed || curr.endTagStart > offset)) {
                    var item = {
                        label: '/' + tag,
                        kind: vscode_languageserver_types_1.CompletionItemKind.Property,
                        filterText: '/' + tag + closeTag,
                        textEdit: vscode_languageserver_types_1.TextEdit.replace(range, '/' + tag + closeTag),
                        insertTextFormat: vscode_languageserver_types_1.InsertTextFormat.PlainText
                    };
                    var startIndent = getLineIndent(curr.start);
                    var endIndent = getLineIndent(afterOpenBracket - 1);
                    if (startIndent !== null && endIndent !== null && startIndent !== endIndent) {
                        var insertText = startIndent + '</' + tag + closeTag;
                        item.textEdit = vscode_languageserver_types_1.TextEdit.replace(getReplaceRange(afterOpenBracket - 1 - endIndent.length), insertText);
                        item.filterText = endIndent + '</' + tag + closeTag;
                    }
                    result.items.push(item);
                    return result;
                }
                curr = curr.parent;
            }
            if (inOpenTag) {
                return result;
            }
            tagProviders.forEach(function (provider) {
                provider.collectTags(function (tag, label) {
                    result.items.push({
                        label: '/' + tag,
                        kind: vscode_languageserver_types_1.CompletionItemKind.Property,
                        documentation: label,
                        filterText: '/' + tag + closeTag,
                        textEdit: vscode_languageserver_types_1.TextEdit.replace(range, '/' + tag + closeTag),
                        insertTextFormat: vscode_languageserver_types_1.InsertTextFormat.PlainText
                    });
                });
            });
            return result;
        }
        function collectAutoCloseTagSuggestion(tagCloseEnd, tag) {
            if (settings && settings.hideAutoCompleteProposals) {
                return result;
            }
            if (!htmlTags_1.isEmptyElement(tag)) {
                var pos = document.positionAt(tagCloseEnd);
                result.items.push({
                    label: '</' + tag + '>',
                    kind: vscode_languageserver_types_1.CompletionItemKind.Property,
                    filterText: '</' + tag + '>',
                    textEdit: vscode_languageserver_types_1.TextEdit.insert(pos, '$0</' + tag + '>'),
                    insertTextFormat: vscode_languageserver_types_1.InsertTextFormat.Snippet
                });
            }
            return result;
        }
        function collectTagSuggestions(tagStart, tagEnd) {
            collectOpenTagSuggestions(tagStart, tagEnd);
            collectCloseTagSuggestions(tagStart, true, tagEnd);
            return result;
        }
        function collectAttributeNameSuggestions(nameStart, nameEnd) {
            if (nameEnd === void 0) { nameEnd = offset; }
            var replaceEnd = offset;
            while (replaceEnd < nameEnd && text[replaceEnd] !== '<') {
                replaceEnd++;
            }
            var range = getReplaceRange(nameStart, replaceEnd);
            var value = isFollowedBy(text, nameEnd, htmlScanner_1.ScannerState.AfterAttributeName, htmlScanner_1.TokenType.DelimiterAssign) ? '' : '="$1"';
            var tag = currentTag.toLowerCase();
            tagProviders.forEach(function (provider) {
                provider.collectAttributes(tag, function (attribute, type) {
                    var codeSnippet = attribute;
                    var command;
                    if (type !== 'v' && value.length) {
                        codeSnippet = codeSnippet + value;
                        if (type) {
                            command = {
                                title: 'Suggest',
                                command: 'editor.action.triggerSuggest'
                            };
                        }
                    }
                    result.items.push({
                        label: attribute,
                        kind: type === 'handler' ? vscode_languageserver_types_1.CompletionItemKind.Function : vscode_languageserver_types_1.CompletionItemKind.Value,
                        textEdit: vscode_languageserver_types_1.TextEdit.replace(range, codeSnippet),
                        insertTextFormat: vscode_languageserver_types_1.InsertTextFormat.Snippet,
                        command: command
                    });
                });
            });
            collectDataAttributesSuggestions(range);
            return result;
        }
        function collectDataAttributesSuggestions(range) {
            var dataAttr = 'data-';
            var dataAttributes = {};
            function addNodeDataAttributes(node) {
                node.attributeNames.forEach(function (attr) {
                    if (strings_1.startsWith(attr, dataAttr) && !dataAttributes[attr]) {
                        dataAttributes[attr] = true;
                    }
                });
                node.children.forEach(function (child) { return addNodeDataAttributes(child); });
            }
            result.items.push({
                label: dataAttr,
                kind: vscode_languageserver_types_1.CompletionItemKind.Value,
                textEdit: vscode_languageserver_types_1.TextEdit.replace(range, dataAttr),
                insertTextFormat: vscode_languageserver_types_1.InsertTextFormat.Snippet
            });
            if (htmlDocument) {
                htmlDocument.roots.forEach(function (root) { return addNodeDataAttributes(root); });
                Object.keys(dataAttributes).forEach(function (attr) { return result.items.push({
                    label: attr,
                    kind: vscode_languageserver_types_1.CompletionItemKind.Value,
                    textEdit: vscode_languageserver_types_1.TextEdit.replace(range, attr + '=""'),
                    insertTextFormat: vscode_languageserver_types_1.InsertTextFormat.Snippet
                }); });
            }
        }
        function collectAttributeValueSuggestions(valueStart, valueEnd) {
            if (valueEnd === void 0) { valueEnd = offset; }
            var range;
            var addQuotes;
            if (offset > valueStart && offset <= valueEnd && text[valueStart] === '"') {
                // inside attribute
                if (valueEnd > offset && text[valueEnd - 1] === '"') {
                    valueEnd--;
                }
                var wsBefore = getWordStart(text, offset, valueStart + 1);
                var wsAfter = getWordEnd(text, offset, valueEnd);
                range = getReplaceRange(wsBefore, wsAfter);
                addQuotes = false;
            }
            else {
                range = getReplaceRange(valueStart, valueEnd);
                addQuotes = true;
            }
            var tag = currentTag.toLowerCase();
            var attribute = currentAttributeName.toLowerCase();
            tagProviders.forEach(function (provider) {
                provider.collectValues(tag, attribute, function (value) {
                    var insertText = addQuotes ? '"' + value + '"' : value;
                    result.items.push({
                        label: value,
                        filterText: insertText,
                        kind: vscode_languageserver_types_1.CompletionItemKind.Unit,
                        textEdit: vscode_languageserver_types_1.TextEdit.replace(range, insertText),
                        insertTextFormat: vscode_languageserver_types_1.InsertTextFormat.PlainText
                    });
                });
            });
            collectCharacterEntityProposals();
            return result;
        }
        function scanNextForEndPos(nextToken) {
            if (offset === scanner.getTokenEnd()) {
                token = scanner.scan();
                if (token === nextToken && scanner.getTokenOffset() === offset) {
                    return scanner.getTokenEnd();
                }
            }
            return offset;
        }
        function collectInsideContent() {
            return collectCharacterEntityProposals();
        }
        function collectCharacterEntityProposals() {
            // character entities
            var k = offset - 1;
            var characterStart = position.character;
            while (k >= 0 && strings_1.isLetterOrDigit(text, k)) {
                k--;
                characterStart--;
            }
            if (k >= 0 && text[k] === '&') {
                var range = vscode_languageserver_types_1.Range.create(vscode_languageserver_types_1.Position.create(position.line, characterStart - 1), position);
                for (var entity in htmlEntities_1.entities) {
                    if (strings_1.endsWith(entity, ';')) {
                        var label = '&' + entity;
                        result.items.push({
                            label: label,
                            kind: vscode_languageserver_types_1.CompletionItemKind.Keyword,
                            documentation: localize('entity.propose', "Character entity representing '" + htmlEntities_1.entities[entity] + "'"),
                            textEdit: vscode_languageserver_types_1.TextEdit.replace(range, label),
                            insertTextFormat: vscode_languageserver_types_1.InsertTextFormat.PlainText
                        });
                    }
                }
            }
            return result;
        }
        var token = scanner.scan();
        while (token !== htmlScanner_1.TokenType.EOS && scanner.getTokenOffset() <= offset) {
            switch (token) {
                case htmlScanner_1.TokenType.StartTagOpen:
                    if (scanner.getTokenEnd() === offset) {
                        var endPos = scanNextForEndPos(htmlScanner_1.TokenType.StartTag);
                        return collectTagSuggestions(offset, endPos);
                    }
                    break;
                case htmlScanner_1.TokenType.StartTag:
                    if (scanner.getTokenOffset() <= offset && offset <= scanner.getTokenEnd()) {
                        return collectOpenTagSuggestions(scanner.getTokenOffset(), scanner.getTokenEnd());
                    }
                    currentTag = scanner.getTokenText();
                    break;
                case htmlScanner_1.TokenType.AttributeName:
                    if (scanner.getTokenOffset() <= offset && offset <= scanner.getTokenEnd()) {
                        return collectAttributeNameSuggestions(scanner.getTokenOffset(), scanner.getTokenEnd());
                    }
                    currentAttributeName = scanner.getTokenText();
                    break;
                case htmlScanner_1.TokenType.DelimiterAssign:
                    if (scanner.getTokenEnd() === offset) {
                        return collectAttributeValueSuggestions(scanner.getTokenEnd());
                    }
                    break;
                case htmlScanner_1.TokenType.AttributeValue:
                    if (scanner.getTokenOffset() <= offset && offset <= scanner.getTokenEnd()) {
                        return collectAttributeValueSuggestions(scanner.getTokenOffset(), scanner.getTokenEnd());
                    }
                    break;
                case htmlScanner_1.TokenType.Whitespace:
                    if (offset <= scanner.getTokenEnd()) {
                        switch (scanner.getScannerState()) {
                            case htmlScanner_1.ScannerState.AfterOpeningStartTag:
                                var startPos = scanner.getTokenOffset();
                                var endTagPos = scanNextForEndPos(htmlScanner_1.TokenType.StartTag);
                                return collectTagSuggestions(startPos, endTagPos);
                            case htmlScanner_1.ScannerState.WithinTag:
                            case htmlScanner_1.ScannerState.AfterAttributeName:
                                return collectAttributeNameSuggestions(scanner.getTokenEnd());
                            case htmlScanner_1.ScannerState.BeforeAttributeValue:
                                return collectAttributeValueSuggestions(scanner.getTokenEnd());
                            case htmlScanner_1.ScannerState.AfterOpeningEndTag:
                                return collectCloseTagSuggestions(scanner.getTokenOffset() - 1, false);
                            case htmlScanner_1.ScannerState.WithinContent:
                                return collectInsideContent();
                        }
                    }
                    break;
                case htmlScanner_1.TokenType.EndTagOpen:
                    if (offset <= scanner.getTokenEnd()) {
                        var afterOpenBracket = scanner.getTokenOffset() + 1;
                        var endOffset = scanNextForEndPos(htmlScanner_1.TokenType.EndTag);
                        return collectCloseTagSuggestions(afterOpenBracket, false, endOffset);
                    }
                    break;
                case htmlScanner_1.TokenType.EndTag:
                    if (offset <= scanner.getTokenEnd()) {
                        var start = scanner.getTokenOffset() - 1;
                        while (start >= 0) {
                            var ch = text.charAt(start);
                            if (ch === '/') {
                                return collectCloseTagSuggestions(start, false, scanner.getTokenEnd());
                            }
                            else if (!isWhiteSpace(ch)) {
                                break;
                            }
                            start--;
                        }
                    }
                    break;
                case htmlScanner_1.TokenType.StartTagClose:
                    if (offset <= scanner.getTokenEnd()) {
                        if (currentTag) {
                            return collectAutoCloseTagSuggestion(scanner.getTokenEnd(), currentTag);
                        }
                    }
                    break;
                case htmlScanner_1.TokenType.Content:
                    if (offset <= scanner.getTokenEnd()) {
                        return collectInsideContent();
                    }
                    break;
                default:
                    if (offset <= scanner.getTokenEnd()) {
                        return result;
                    }
                    break;
            }
            token = scanner.scan();
        }
        return result;
    }
    exports.doComplete = doComplete;
    function doTagComplete(document, position, htmlDocument) {
        var offset = document.offsetAt(position);
        if (offset <= 0) {
            return null;
        }
        var char = document.getText().charAt(offset - 1);
        if (char === '>') {
            var node = htmlDocument.findNodeBefore(offset);
            if (node && node.tag && !htmlTags_1.isEmptyElement(node.tag) && node.start < offset && (!node.endTagStart || node.endTagStart > offset)) {
                var scanner = htmlScanner_1.createScanner(document.getText(), node.start);
                var token = scanner.scan();
                while (token !== htmlScanner_1.TokenType.EOS && scanner.getTokenEnd() <= offset) {
                    if (token === htmlScanner_1.TokenType.StartTagClose && scanner.getTokenEnd() === offset) {
                        return "$0</" + node.tag + ">";
                    }
                    token = scanner.scan();
                }
            }
        }
        else if (char === '/') {
            var node = htmlDocument.findNodeBefore(offset);
            while (node && node.closed) {
                node = node.parent;
            }
            if (node && node.tag) {
                var scanner = htmlScanner_1.createScanner(document.getText(), node.start);
                var token = scanner.scan();
                while (token !== htmlScanner_1.TokenType.EOS && scanner.getTokenEnd() <= offset) {
                    if (token === htmlScanner_1.TokenType.EndTagOpen && scanner.getTokenEnd() === offset) {
                        return node.tag + ">";
                    }
                    token = scanner.scan();
                }
            }
        }
        return null;
    }
    exports.doTagComplete = doTagComplete;
    function isWhiteSpace(s) {
        return /^\s*$/.test(s);
    }
    function isWhiteSpaceOrQuote(s) {
        return /^[\s"]*$/.test(s);
    }
    function isFollowedBy(s, offset, intialState, expectedToken) {
        var scanner = htmlScanner_1.createScanner(s, offset, intialState);
        var token = scanner.scan();
        while (token === htmlScanner_1.TokenType.Whitespace) {
            token = scanner.scan();
        }
        return token === expectedToken;
    }
    function getWordStart(s, offset, limit) {
        while (offset > limit && !isWhiteSpace(s[offset - 1])) {
            offset--;
        }
        return offset;
    }
    function getWordEnd(s, offset, limit) {
        while (offset < limit && !isWhiteSpace(s[offset])) {
            offset++;
        }
        return offset;
    }
});
//# sourceMappingURL=htmlCompletion.js.map