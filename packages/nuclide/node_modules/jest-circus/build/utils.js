'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.invariant = exports.addErrorToEachTestUnderDescribe = exports.getTestID = exports.makeRunResult = exports.getTestDuration = exports.callAsyncCircusFn = exports.describeBlockHasTests = exports.getEachHooksForTest = exports.getAllHooksForDescribe = exports.makeTest = exports.makeDescribe = exports.getOriginalPromise = undefined;

var _jestUtil = require('jest-util');

var _isGeneratorFn = require('is-generator-fn');

var _isGeneratorFn2 = _interopRequireDefault(_isGeneratorFn);

var _co = require('co');

var _co2 = _interopRequireDefault(_co);

var _stackUtils = require('stack-utils');

var _stackUtils2 = _interopRequireDefault(_stackUtils);

var _prettyFormat = require('pretty-format');

var _prettyFormat2 = _interopRequireDefault(_prettyFormat);

var _state = require('./state');

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {default: obj};
}

function _toConsumableArray(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++)
      arr2[i] = arr[i];
    return arr2;
  } else {
    return Array.from(arr);
  }
}
/**
 * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 *  strict-local
 */

// Try getting the real promise object from the context, if available. Someone
// could have overridden it in a test. Async functions return it implicitly.
// eslint-disable-next-line no-unused-vars
const Promise = global[Symbol.for('jest-native-promise')] || global.Promise;
const getOriginalPromise = (exports.getOriginalPromise = () => Promise);

const stackUtils = new _stackUtils2.default({
  cwd: 'A path that does not exist'
});

const makeDescribe = (exports.makeDescribe = (name, parent, mode) => {
  let _mode = mode;
  if (parent && !mode) {
    // If not set explicitly, inherit from the parent describe.
    _mode = parent.mode;
  }

  return {
    children: [],
    hooks: [],
    mode: _mode,
    name: (0, _jestUtil.convertDescriptorToString)(name),
    parent: parent,
    tests: []
  };
});

const makeTest = (exports.makeTest = (
  fn,
  mode,
  name,
  parent,
  timeout,
  asyncError
) => {
  let _mode = mode;
  if (!mode) {
    // if not set explicitly, inherit from its parent describe
    _mode = parent.mode;
  }

  return {
    asyncError: asyncError,
    duration: null,
    errors: [],
    fn: fn,
    invocations: 0,
    mode: _mode,
    name: (0, _jestUtil.convertDescriptorToString)(name),
    parent: parent,
    startedAt: null,
    status: null,
    timeout: timeout
  };
});

// Traverse the tree of describe blocks and return true if at least one describe
// block has an enabled test.
const hasEnabledTest = describeBlock => {
  var _getState = (0, _state.getState)();

  const hasFocusedTests = _getState.hasFocusedTests,
    testNamePattern = _getState.testNamePattern;

  const hasOwnEnabledTests = describeBlock.tests.some(
    test =>
      !(
        test.mode === 'skip' ||
        (hasFocusedTests && test.mode !== 'only') ||
        (testNamePattern && !testNamePattern.test(getTestID(test)))
      )
  );

  return hasOwnEnabledTests || describeBlock.children.some(hasEnabledTest);
};

const getAllHooksForDescribe = (exports.getAllHooksForDescribe = describe => {
  const result = {afterAll: [], beforeAll: []};

  if (hasEnabledTest(describe)) {
    for (const hook of describe.hooks) {
      switch (hook.type) {
        case 'beforeAll':
          result.beforeAll.push(hook);
          break;
        case 'afterAll':
          result.afterAll.push(hook);
          break;
      }
    }
  }

  return result;
});

const getEachHooksForTest = (exports.getEachHooksForTest = test => {
  const result = {afterEach: [], beforeEach: []};
  let block = test.parent;

  do {
    const beforeEachForCurrentBlock = [];
    for (const hook of block.hooks) {
      switch (hook.type) {
        case 'beforeEach':
          beforeEachForCurrentBlock.push(hook);
          break;
        case 'afterEach':
          result.afterEach.push(hook);
          break;
      }
    }
    // 'beforeEach' hooks are executed from top to bottom, the opposite of the
    // way we traversed it.
    result.beforeEach = [].concat(
      beforeEachForCurrentBlock,
      _toConsumableArray(result.beforeEach)
    );
  } while ((block = block.parent));
  return result;
});

const describeBlockHasTests = (exports.describeBlockHasTests = describe =>
  describe.tests.length || describe.children.some(describeBlockHasTests));

const _makeTimeoutMessage = (timeout, isHook) =>
  `Exceeded timeout of ${timeout}ms for a ${
    isHook ? 'hook' : 'test'
  }.\nUse jest.setTimeout(newTimeout) to increase the timeout value, if this is a long-running test.`;

// Global values can be overwritten by mocks or tests. We'll capture
// the original values in the variables before we require any files.
var _global = global;
const setTimeout = _global.setTimeout,
  clearTimeout = _global.clearTimeout;
const callAsyncCircusFn = (exports.callAsyncCircusFn = (
  fn,
  testContext,
  _ref
) => {
  let isHook = _ref.isHook,
    timeout = _ref.timeout;

  let timeoutID;

  return new Promise((resolve, reject) => {
    timeoutID = setTimeout(
      () => reject(_makeTimeoutMessage(timeout, isHook)),
      timeout
    );

    // If this fn accepts `done` callback we return a promise that fulfills as
    // soon as `done` called.
    if (fn.length) {
      const done = reason => {
        // $FlowFixMe: It doesn't approve of .stack
        const isError = reason && reason.message && reason.stack;
        return reason
          ? reject(
              isError
                ? reason
                : new Error(
                    `Failed: ${(0, _prettyFormat2.default)(reason, {
                      maxDepth: 3
                    })}`
                  )
            )
          : resolve();
      };

      return fn.call(testContext, done);
    }

    let returnedValue;
    if ((0, _isGeneratorFn2.default)(fn)) {
      returnedValue = _co2.default.wrap(fn).call({});
    } else {
      try {
        returnedValue = fn.call(testContext);
      } catch (error) {
        return reject(error);
      }
    }

    // If it's a Promise, return it. Test for an object with a `then` function
    // to support custom Promise implementations.
    if (
      typeof returnedValue === 'object' &&
      returnedValue !== null &&
      typeof returnedValue.then === 'function'
    ) {
      return returnedValue.then(resolve, reject);
    }

    if (!isHook && returnedValue !== void 0) {
      return reject(
        new Error(`
      test functions can only return Promise or undefined.
      Returned value: ${String(returnedValue)}
      `)
      );
    }

    // Otherwise this test is synchronous, and if it didn't throw it means
    // it passed.
    return resolve();
  })
    .then(() => {
      // If timeout is not cleared/unrefed the node process won't exit until
      // it's resolved.
      timeoutID.unref && timeoutID.unref();
      clearTimeout(timeoutID);
    })
    .catch(error => {
      timeoutID.unref && timeoutID.unref();
      clearTimeout(timeoutID);
      throw error;
    });
});

const getTestDuration = (exports.getTestDuration = test => {
  const startedAt = test.startedAt;

  return startedAt ? Date.now() - startedAt : null;
});

const makeRunResult = (exports.makeRunResult = (
  describeBlock,
  unhandledErrors
) => ({
  testResults: makeTestResults(describeBlock),
  unhandledErrors: unhandledErrors.map(_formatError)
}));

const makeTestResults = (describeBlock, config) => {
  var _getState2 = (0, _state.getState)();

  const includeTestLocationInResult = _getState2.includeTestLocationInResult;

  let testResults = [];
  for (const test of describeBlock.tests) {
    const testPath = [];
    let parent = test;
    do {
      testPath.unshift(parent.name);
    } while ((parent = parent.parent));

    const status = test.status;

    if (!status) {
      throw new Error('Status should be present after tests are run.');
    }

    let location = null;
    if (includeTestLocationInResult) {
      const stackLine = test.asyncError.stack.split('\n')[1];

      var _stackUtils$parseLine = stackUtils.parseLine(stackLine);

      const line = _stackUtils$parseLine.line,
        column = _stackUtils$parseLine.column;

      location = {column: column, line: line};
    }

    testResults.push({
      duration: test.duration,
      errors: test.errors.map(_formatError),
      invocations: test.invocations,
      location: location,
      status: status,
      testPath: testPath
    });
  }

  for (const child of describeBlock.children) {
    testResults = testResults.concat(makeTestResults(child, config));
  }

  return testResults;
};

// Return a string that identifies the test (concat of parent describe block
// names + test title)
const getTestID = (exports.getTestID = test => {
  const titles = [];
  let parent = test;
  do {
    titles.unshift(parent.name);
  } while ((parent = parent.parent));

  titles.shift(); // remove TOP_DESCRIBE_BLOCK_NAME
  return titles.join(' ');
});

const _formatError = errors => {
  let error;
  let asyncError;

  if (Array.isArray(errors)) {
    error = errors[0];
    asyncError = errors[1];
  } else {
    error = errors;
    asyncError = new Error();
  }

  if (error) {
    if (error.stack) {
      return error.stack;
    }
    if (error.message) {
      return error.message;
    }
  }

  asyncError.message = `thrown: ${(0, _prettyFormat2.default)(error, {
    maxDepth: 3
  })}`;

  return asyncError.stack;
};

const addErrorToEachTestUnderDescribe = (exports.addErrorToEachTestUnderDescribe = (
  describeBlock,
  error,
  asyncError
) => {
  for (const test of describeBlock.tests) {
    test.errors.push([error, asyncError]);
  }

  for (const child of describeBlock.children) {
    addErrorToEachTestUnderDescribe(child, error, asyncError);
  }
});

const invariant = (exports.invariant = (condition, message) => {
  if (!condition) {
    throw new Error(message);
  }
});
