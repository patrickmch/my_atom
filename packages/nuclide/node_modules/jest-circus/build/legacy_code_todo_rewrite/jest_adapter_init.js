'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.runAndTransformResultsToJestFormat = exports.initialize = undefined;

var _expect = require('expect');

var _jestMessageUtil = require('jest-message-util');

var _jestSnapshot = require('jest-snapshot');

var _state = require('../state');

var _utils = require('../utils');

var _run = require('../run');

var _run2 = _interopRequireDefault(_run);

var _index = require('../index');

var _index2 = _interopRequireDefault(_index);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {default: obj};
}

function _asyncToGenerator(fn) {
  return function() {
    var gen = fn.apply(this, arguments);
    return new Promise(function(resolve, reject) {
      function step(key, arg) {
        try {
          var info = gen[key](arg);
          var value = info.value;
        } catch (error) {
          reject(error);
          return;
        }
        if (info.done) {
          resolve(value);
        } else {
          return Promise.resolve(value).then(
            function(value) {
              step('next', value);
            },
            function(err) {
              step('throw', err);
            }
          );
        }
      }
      return step('next');
    });
  };
}
/**
 * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 *
 */

// eslint-disable-next-line import/default

const Promise = (0, _utils.getOriginalPromise)();
const initialize = (exports.initialize = _ref => {
  let config = _ref.config,
    getPrettier = _ref.getPrettier,
    getBabelTraverse = _ref.getBabelTraverse,
    globalConfig = _ref.globalConfig,
    localRequire = _ref.localRequire,
    parentProcess = _ref.parentProcess,
    testPath = _ref.testPath;

  Object.assign(global, _index2.default);

  global.xit = global.it.skip;
  global.xtest = global.it.skip;
  global.xdescribe = global.describe.skip;
  global.fit = global.it.only;
  global.fdescribe = global.describe.only;

  global.test.concurrent = (testName, testFn, timeout) => {
    // For concurrent tests we first run the function that returns promise, and then register a
    // nomral test that will be waiting on the returned promise (when we start the test, the promise
    // will already be in the process of execution).
    // Unfortunately at this stage there's no way to know if there are any `.only` tests in the suite
    // that will result in this test to be skipped, so we'll be executing the promise function anyway,
    // even if it ends up being skipped.
    const promise = testFn();
    global.test(testName, () => promise, timeout);
  };

  global.test.concurrent.only = (testName, testFn, timeout) => {
    const promise = testFn();
    global.test.only(testName, () => promise, timeout);
  };

  global.test.concurrent.skip = global.test.skip;

  (0, _state.addEventHandler)(eventHandler);

  (0, _state.dispatch)({
    name: 'setup',
    parentProcess: parentProcess,
    testNamePattern: globalConfig.testNamePattern
  });

  if (config.testLocationInResults) {
    (0, _state.dispatch)({
      name: 'include_test_location_in_result'
    });
  }

  // Jest tests snapshotSerializers in order preceding built-in serializers.
  // Therefore, add in reverse because the last added is the first tested.
  config.snapshotSerializers
    .concat()
    .reverse()
    .forEach(path => {
      (0, _jestSnapshot.addSerializer)(localRequire(path));
    });

  const expand = globalConfig.expand,
    updateSnapshot = globalConfig.updateSnapshot;

  const snapshotState = new _jestSnapshot.SnapshotState(testPath, {
    expand: expand,
    getBabelTraverse: getBabelTraverse,
    getPrettier: getPrettier,
    updateSnapshot: updateSnapshot
  });
  (0, _expect.setState)({snapshotState: snapshotState, testPath: testPath});

  // Return it back to the outer scope (test runner outside the VM).
  return {globals: _index2.default, snapshotState: snapshotState};
});

const runAndTransformResultsToJestFormat = (exports.runAndTransformResultsToJestFormat = (() => {
  var _ref3 = _asyncToGenerator(function*(_ref2) {
    let config = _ref2.config,
      globalConfig = _ref2.globalConfig,
      testPath = _ref2.testPath;

    const runResult = yield (0, _run2.default)();

    let numFailingTests = 0;
    let numPassingTests = 0;
    let numPendingTests = 0;

    const assertionResults = runResult.testResults.map(function(testResult) {
      let status;
      if (testResult.status === 'skip') {
        status = 'pending';
        numPendingTests += 1;
      } else if (testResult.errors.length) {
        status = 'failed';
        numFailingTests += 1;
      } else {
        status = 'passed';
        numPassingTests += 1;
      }

      const ancestorTitles = testResult.testPath.filter(function(name) {
        return name !== _state.ROOT_DESCRIBE_BLOCK_NAME;
      });
      const title = ancestorTitles.pop();

      return {
        ancestorTitles: ancestorTitles,
        duration: testResult.duration,
        failureMessages: testResult.errors,
        fullName: ancestorTitles.concat(title).join(' '),
        invocations: testResult.invocations,
        location: testResult.location,
        numPassingAsserts: 0,
        status: status,
        title: testResult.testPath[testResult.testPath.length - 1]
      };
    });

    let failureMessage = (0, _jestMessageUtil.formatResultsErrors)(
      assertionResults,
      config,
      globalConfig,
      testPath
    );
    let testExecError;

    if (runResult.unhandledErrors.length) {
      testExecError = {
        message: '',
        stack: runResult.unhandledErrors.join('\n')
      };
      failureMessage =
        (failureMessage || '') +
        '\n\n' +
        runResult.unhandledErrors
          .map(function(err) {
            return (0,
            _jestMessageUtil.formatExecError)(err, config, globalConfig);
          })
          .join('\n');
    }

    (0, _state.dispatch)({name: 'teardown'});
    return {
      console: null,
      displayName: config.displayName,
      failureMessage: failureMessage,
      leaks: false, // That's legacy code, just adding it so Flow is happy.
      numFailingTests: numFailingTests,
      numPassingTests: numPassingTests,
      numPendingTests: numPendingTests,
      openHandles: [],
      perfStats: {
        // populated outside
        end: 0,
        start: 0
      },
      skipped: false,
      snapshot: {
        added: 0,
        fileDeleted: false,
        matched: 0,
        unchecked: 0,
        uncheckedKeys: [],
        unmatched: 0,
        updated: 0
      },
      sourceMaps: {},
      testExecError: testExecError,
      testFilePath: testPath,
      testResults: assertionResults
    };
  });

  return function runAndTransformResultsToJestFormat(_x) {
    return _ref3.apply(this, arguments);
  };
})());

const eventHandler = event => {
  switch (event.name) {
    case 'test_start': {
      (0, _expect.setState)({
        currentTestName: (0, _utils.getTestID)(event.test)
      });
      break;
    }
    case 'test_done': {
      _addSuppressedErrors(event.test);
      _addExpectedAssertionErrors(event.test);
      break;
    }
  }
};

const _addExpectedAssertionErrors = test => {
  const failures = (0, _expect.extractExpectedAssertionsErrors)();
  const errors = failures.map(failure => failure.error);
  test.errors = test.errors.concat(errors);
};

// Get suppressed errors from ``jest-matchers`` that weren't throw during
// test execution and add them to the test result, potentially failing
// a passing test.
const _addSuppressedErrors = test => {
  var _getState = (0, _expect.getState)();

  const suppressedErrors = _getState.suppressedErrors;

  (0, _expect.setState)({suppressedErrors: []});
  if (suppressedErrors.length) {
    test.errors = test.errors.concat(suppressedErrors);
  }
};
