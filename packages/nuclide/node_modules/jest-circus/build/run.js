'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _state = require('./state');

var _utils = require('./utils');

function _asyncToGenerator(fn) {
  return function() {
    var gen = fn.apply(this, arguments);
    return new Promise(function(resolve, reject) {
      function step(key, arg) {
        try {
          var info = gen[key](arg);
          var value = info.value;
        } catch (error) {
          reject(error);
          return;
        }
        if (info.done) {
          resolve(value);
        } else {
          return Promise.resolve(value).then(
            function(value) {
              step('next', value);
            },
            function(err) {
              step('throw', err);
            }
          );
        }
      }
      return step('next');
    });
  };
}
/**
 * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 *  strict-local
 */

const Promise = (0, _utils.getOriginalPromise)();

const run = (() => {
  var _ref = _asyncToGenerator(function*() {
    var _getState = (0, _state.getState)();

    const rootDescribeBlock = _getState.rootDescribeBlock;

    (0, _state.dispatch)({name: 'run_start'});
    yield _runTestsForDescribeBlock(rootDescribeBlock);
    (0, _state.dispatch)({name: 'run_finish'});
    return (0,
    _utils.makeRunResult)((0, _state.getState)().rootDescribeBlock, (0, _state.getState)().unhandledErrors);
  });

  return function run() {
    return _ref.apply(this, arguments);
  };
})();

const _runTestsForDescribeBlock = (() => {
  var _ref2 = _asyncToGenerator(function*(describeBlock) {
    (0,
    _state.dispatch)({describeBlock: describeBlock, name: 'run_describe_start'});

    var _getAllHooksForDescri = (0, _utils.getAllHooksForDescribe)(
      describeBlock
    );

    const beforeAll = _getAllHooksForDescri.beforeAll,
      afterAll = _getAllHooksForDescri.afterAll;

    for (const hook of beforeAll) {
      yield _callCircusHook({describeBlock: describeBlock, hook: hook});
    }

    // Tests that fail and are retried we run after other tests
    const retryTimes = parseInt(global[Symbol.for('RETRY_TIMES')], 10) || 0;
    const deferredRetryTests = [];

    for (const test of describeBlock.tests) {
      yield _runTest(test);

      if (retryTimes > 0 && test.errors.length > 0) {
        deferredRetryTests.push(test);
      }
    }

    // Re-run failed tests n-times if configured
    for (const test of deferredRetryTests) {
      let numRetriesAvailable = retryTimes;

      while (numRetriesAvailable > 0 && test.errors.length > 0) {
        // Clear errors so retries occur
        (0, _state.dispatch)({name: 'test_retry', test: test});

        yield _runTest(test);
        numRetriesAvailable--;
      }
    }

    for (const child of describeBlock.children) {
      yield _runTestsForDescribeBlock(child);
    }

    for (const hook of afterAll) {
      yield _callCircusHook({describeBlock: describeBlock, hook: hook});
    }
    (0,
    _state.dispatch)({describeBlock: describeBlock, name: 'run_describe_finish'});
  });

  return function _runTestsForDescribeBlock(_x) {
    return _ref2.apply(this, arguments);
  };
})();

const _runTest = (() => {
  var _ref3 = _asyncToGenerator(function*(test) {
    (0, _state.dispatch)({name: 'test_start', test: test});
    const testContext = Object.create(null);

    var _getState2 = (0, _state.getState)();

    const hasFocusedTests = _getState2.hasFocusedTests,
      testNamePattern = _getState2.testNamePattern;

    const isSkipped =
      test.mode === 'skip' ||
      (hasFocusedTests && test.mode !== 'only') ||
      (testNamePattern && !testNamePattern.test((0, _utils.getTestID)(test)));

    if (isSkipped) {
      (0, _state.dispatch)({name: 'test_skip', test: test});
      return;
    }

    var _getEachHooksForTest = (0, _utils.getEachHooksForTest)(test);

    const afterEach = _getEachHooksForTest.afterEach,
      beforeEach = _getEachHooksForTest.beforeEach;

    for (const hook of beforeEach) {
      if (test.errors.length) {
        // If any of the before hooks failed already, we don't run any
        // hooks after that.
        break;
      }
      yield _callCircusHook({hook: hook, test: test, testContext: testContext});
    }

    yield _callCircusTest(test, testContext);

    for (const hook of afterEach) {
      yield _callCircusHook({hook: hook, test: test, testContext: testContext});
    }

    // `afterAll` hooks should not affect test status (pass or fail), because if
    // we had a global `afterAll` hook it would block all existing tests until
    // this hook is executed. So we dispatche `test_done` right away.
    (0, _state.dispatch)({name: 'test_done', test: test});
  });

  return function _runTest(_x2) {
    return _ref3.apply(this, arguments);
  };
})();

const _callCircusHook = _ref4 => {
  let hook = _ref4.hook,
    test = _ref4.test,
    describeBlock = _ref4.describeBlock,
    testContext = _ref4.testContext;

  (0, _state.dispatch)({hook: hook, name: 'hook_start'});
  const timeout = hook.timeout || (0, _state.getState)().testTimeout;
  return (0, _utils.callAsyncCircusFn)(hook.fn, testContext, {
    isHook: true,
    timeout: timeout
  })
    .then(() =>
      (0, _state.dispatch)({
        describeBlock: describeBlock,
        hook: hook,
        name: 'hook_success',
        test: test
      })
    )
    .catch(error =>
      (0, _state.dispatch)({
        describeBlock: describeBlock,
        error: error,
        hook: hook,
        name: 'hook_failure',
        test: test
      })
    );
};

const _callCircusTest = (test, testContext) => {
  (0, _state.dispatch)({name: 'test_fn_start', test: test});
  const timeout = test.timeout || (0, _state.getState)().testTimeout;
  (0, _utils.invariant)(
    test.fn,
    `Tests with no 'fn' should have 'mode' set to 'skipped'`
  );

  if (test.errors.length) {
    // We don't run the test if there's already an error in before hooks.
    return Promise.resolve();
  }

  return (0, _utils.callAsyncCircusFn)(test.fn, testContext, {
    isHook: false,
    timeout: timeout
  })
    .then(() => (0, _state.dispatch)({name: 'test_fn_success', test: test}))
    .catch(error =>
      (0, _state.dispatch)({error: error, name: 'test_fn_failure', test: test})
    );
};

exports.default = run;
