'use strict';

var _jestEach = require('jest-each');

var _state = require('./state');

const describe = (blockName, blockFn) => _dispatchDescribe(blockFn, blockName);
/**
 * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 *  strict-local
 */

describe.only = (blockName, blockFn) =>
  _dispatchDescribe(blockFn, blockName, 'only');
describe.skip = (blockName, blockFn) =>
  _dispatchDescribe(blockFn, blockName, 'skip');

const _dispatchDescribe = (blockFn, blockName, mode) => {
  (0, _state.dispatch)({
    asyncError: new Error(),
    blockName: blockName,
    mode: mode,
    name: 'start_describe_definition'
  });
  blockFn();
  (0, _state.dispatch)({
    blockName: blockName,
    mode: mode,
    name: 'finish_describe_definition'
  });
};

const _addHook = (fn, hookType, hookFn, timeout) => {
  if (typeof fn !== 'function') {
    throw new Error('Invalid first argument. It must be a callback function.');
  }

  const asyncError = new Error();
  if (Error.captureStackTrace) {
    Error.captureStackTrace(asyncError, hookFn);
  }
  (0, _state.dispatch)({
    asyncError: asyncError,
    fn: fn,
    hookType: hookType,
    name: 'add_hook',
    timeout: timeout
  });
};

// Hooks have to pass themselves to the HOF in order for us to trim stack traces.
const beforeEach = (fn, timeout) =>
  _addHook(fn, 'beforeEach', beforeEach, timeout);
const beforeAll = (fn, timeout) =>
  _addHook(fn, 'beforeAll', beforeAll, timeout);
const afterEach = (fn, timeout) =>
  _addHook(fn, 'afterEach', afterEach, timeout);
const afterAll = (fn, timeout) => _addHook(fn, 'afterAll', afterAll, timeout);

const test = (testName, fn, timeout) => {
  if (typeof testName !== 'string') {
    throw new Error(
      `Invalid first argument, ${testName}. It must be a string.`
    );
  }
  if (fn === undefined) {
    throw new Error('Missing second argument. It must be a callback function.');
  }
  if (typeof fn !== 'function') {
    throw new Error(
      `Invalid second argument, ${fn}. It must be a callback function.`
    );
  }

  const asyncError = new Error();
  if (Error.captureStackTrace) {
    Error.captureStackTrace(asyncError, test);
  }

  return (0, _state.dispatch)({
    asyncError: asyncError,
    fn: fn,
    name: 'add_test',
    testName: testName,
    timeout: timeout
  });
};
const it = test;
test.skip = (testName, fn, timeout) => {
  const asyncError = new Error();
  if (Error.captureStackTrace) {
    Error.captureStackTrace(asyncError, test);
  }

  return (0, _state.dispatch)({
    asyncError: asyncError,
    fn: fn,
    mode: 'skip',
    name: 'add_test',
    testName: testName,
    timeout: timeout
  });
};
test.only = (testName, fn, timeout) => {
  const asyncError = new Error();
  if (Error.captureStackTrace) {
    Error.captureStackTrace(asyncError, test);
  }

  return (0, _state.dispatch)({
    asyncError: asyncError,
    fn: fn,
    mode: 'only',
    name: 'add_test',
    testName: testName,
    timeout: timeout
  });
};

test.each = (0, _jestEach.bind)(test);
test.only.each = (0, _jestEach.bind)(test.only);
test.skip.each = (0, _jestEach.bind)(test.skip);

describe.each = (0, _jestEach.bind)(describe, false);
describe.only.each = (0, _jestEach.bind)(describe.only, false);
describe.skip.each = (0, _jestEach.bind)(describe.skip, false);

module.exports = {
  afterAll: afterAll,
  afterEach: afterEach,
  beforeAll: beforeAll,
  beforeEach: beforeEach,
  describe: describe,
  it: it,
  test: test
};
